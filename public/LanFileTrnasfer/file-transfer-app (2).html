<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC P2P File Transfer (Fixed)</title>
    <script src="https://cdn.jsdelivr.net/gh/davidshimjs/qrcodejs/qrcode.min.js"></script>
    
    <style>
        body { 
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            padding: 1em; 
            line-height: 1.5; 
            max-width: 900px; 
            margin: auto; 
            background: #f5f7fa; 
            color: #333;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 { 
            text-align: center; 
            color: #2563eb; 
            margin-bottom: 0.5rem;
        }
        .subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 2rem;
        }
        textarea { 
            width: 100%; 
            height: 100px; 
            margin: 10px 0; 
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9em;
            resize: vertical;
        }
        button { 
            margin: 5px; 
            padding: 10px 16px; 
            cursor: pointer; 
            background: #2563eb; 
            color: white; 
            border: none; 
            border-radius: 6px; 
            font-weight: 500;
            transition: all 0.2s;
        }
        button:hover { background: #1d4ed8; }
        button:disabled { 
            background: #9ca3af; 
            cursor: not-allowed; 
        }
        .btn-success { background: #059669; }
        .btn-success:hover { background: #047857; }
        .btn-warning { background: #d97706; }
        .btn-warning:hover { background: #b45309; }
        
        input[type="text"], input[type="file"] { 
            padding: 10px; 
            margin: 5px; 
            border: 2px solid #e5e7eb; 
            border-radius: 6px; 
            font-size: 1rem;
        }
        
        .status {
            font-weight: bold; 
            margin: 20px 0; 
            padding: 15px; 
            border-radius: 8px; 
            text-align: center;
            font-size: 1.1rem;
        }
        .status-disconnected { background: #fef2f2; color: #dc2626; border: 2px solid #fecaca; }
        .status-connecting { background: #fffbeb; color: #d97706; border: 2px solid #fed7aa; }
        .status-connected { background: #f0fdf4; color: #16a34a; border: 2px solid #bbf7d0; }
        
        .section {
            margin: 30px 0;
            padding: 25px;
            background: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .section h2 {
            margin: 0 0 20px 0;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
        }
        .step {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #2563eb;
        }
        .step-title {
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 10px;
        }
        
        .hidden { display: none; }
        
        #chat-log { 
            border: 2px solid #e5e7eb; 
            padding: 15px; 
            min-height: 120px; 
            margin: 15px 0; 
            background: white; 
            max-height: 300px; 
            overflow-y: auto; 
            border-radius: 6px;
            font-family: system-ui;
        }
        .chat-message {
            margin: 8px 0;
            padding: 8px;
            border-radius: 4px;
        }
        .chat-me { background: #dbeafe; border-left: 3px solid #2563eb; }
        .chat-peer { background: #f3f4f6; border-left: 3px solid #6b7280; }
        .chat-system { background: #fef3c7; border-left: 3px solid #d97706; font-style: italic; }
        
        .file-transfer {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        .file-transfer input[type="file"] {
            flex: 1;
        }
        
        .progress-section {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }
        progress { 
            width: 100%; 
            height: 20px; 
            margin: 10px 0;
            border-radius: 10px;
        }
        progress::-webkit-progress-bar { 
            background: #f3f4f6; 
            border-radius: 10px; 
        }
        progress::-webkit-progress-value { 
            background: #10b981; 
            border-radius: 10px; 
        }
        
        .download-link {
            display: inline-block;
            margin: 10px 0;
            padding: 12px 20px;
            background: #059669;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 500;
        }
        .download-link:hover {
            background: #047857;
        }
        
        .instructions {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        .instructions h3 {
            margin: 0 0 10px 0;
            color: #1e40af;
        }
        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        .instructions li {
            margin: 5px 0;
        }

        .qr-container {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        }
        
        .qr-container.hidden {
            display: none;
        }
        
        .qr-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .qr-container h4 {
            margin: 0;
            font-size: 14px;
            color: #374151;
        }
        
        .qr-close-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .qr-close-btn:hover {
            background: #dc2626;
        }
        
        #qr-code {
            display: block;
            margin: 0 auto;
        }
        
        #qr-code img {
            display: block;
            margin: 0 auto;
        }
        
        .qr-url {
            font-size: 12px;
            color: #6b7280;
            margin-top: 10px;
            word-break: break-all;
            max-width: 200px;
        }

        @media (max-width: 768px) {
            .qr-container {
                position: relative;
                top: auto;
                right: auto;
                margin: 20px auto;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="qr-container" id="qr-container">
        <div class="qr-header">
            <h4>üì± Share This Page</h4>
            <button class="qr-close-btn" id="qr-close-btn">√ó</button>
        </div>
        <div id="qr-code"></div>
        <div class="qr-url" id="qr-url-text"></div>
    </div>

    <div class="container">
        <h1>üì° WebRTC P2P File Transfer</h1>
        <div class="subtitle">Direct device-to-device file sharing</div>

        <div id="status" class="status status-disconnected">Not Connected</div>

        <div class="instructions">
            <h3>üîß How to Connect:</h3>
            <ol>
                <li><strong>üéß Device A (Host):</strong> Click "Start Listening" button</li>
                <li><strong>üìû Device B (Client):</strong> Enter Device A's IP address and click "Connect to IP"</li>
                <li><strong>üéâ Connected!</strong> Chat and transfer files</li>
            </ol>
            <div style="background: #fffbeb; padding: 15px; border-radius: 6px; margin-top: 15px; border-left: 4px solid #d97706;">
                <strong>üí° Alternative:</strong> If direct IP connection doesn't work, use the manual WebRTC method below
            </div>
        </div>

        <!-- Connection Setup -->
        <div class="section">
            <h2>üîó Connection Setup</h2>
            
            <div class="step">
                <div class="step-title">üåê Direct IP Connection (Local Network)</div>
                <div style="margin: 15px 0;">
                    <strong>Your Local IP Address:</strong> <span id="local-ip-display">Detecting...</span>
                    <button id="refresh-ip-btn" class="btn-warning" style="margin-left: 10px;">Refresh IP</button>
                </div>
                
                <div style="display: flex; gap: 10px; margin: 15px 0;">
                    <button id="listen-btn" class="btn-success" style="flex: 1;">üéß Start Listening</button>
                    <span style="padding: 10px; color: #666;">OR</span>
                    <button id="stop-listen-btn" class="btn-warning" style="flex: 1; display: none;">üõë Stop Listening</button>
                </div>
                
                <div style="display: flex; gap: 10px; align-items: center; margin: 15px 0;">
                    <input type="text" id="target-ip-input" placeholder="Enter other device's IP address" style="flex: 1;">
                    <input type="number" id="target-port-input" placeholder="Port" value="3000" style="width: 100px;">
                    <button id="connect-ip-btn" class="btn-success">üìû Connect to IP</button>
                </div>
                
                <div id="listen-status" style="margin: 15px 0; padding: 10px; background: #f9fafb; border-radius: 6px; display: none;">
                    <strong>Status:</strong> <span id="listen-status-text">Not listening</span>
                </div>
            </div>

            <div class="step">
                <div class="step-title">Step 1: Create Offer (Device A) - WebRTC Method</div>
                <button id="create-offer-btn">Create Offer</button>
                <textarea id="offer-output" placeholder="Offer will appear here - copy to Device B" readonly></textarea>
            </div>

            <div class="step">
                <div class="step-title">Step 2: Create Answer (Device B)</div>
                <textarea id="offer-input" placeholder="Paste offer from Device A here"></textarea>
                <button id="create-answer-btn">Create Answer</button>
                <textarea id="answer-output" placeholder="Answer will appear here - copy to Device A" readonly></textarea>
            </div>

            <div class="step">
                <div class="step-title">Step 3: Set Answer (Device A)</div>
                <textarea id="answer-input" placeholder="Paste answer from Device B here"></textarea>
                <button id="set-answer-btn">Set Answer</button>
            </div>

            <div class="step">
                <div class="step-title">Step 4: Exchange ICE Candidates (Both Devices)</div>
                <div style="margin: 10px 0;">
                    <strong>Your ICE Candidates (copy these):</strong>
                    <textarea id="ice-output" placeholder="Your ICE candidates will appear here..." readonly></textarea>
                </div>
                <div style="margin: 10px 0;">
                    <strong>Paste Remote ICE Candidates:</strong>
                    <textarea id="ice-input" placeholder="Paste ICE candidates from other device here"></textarea>
                    <button id="add-ice-btn">Add ICE Candidates</button>
                </div>
            </div>
        </div>

        <!-- Chat Section -->
        <div id="chat-section" class="section hidden">
            <h2>üí¨ Chat</h2>
            <div id="chat-log"></div>
            <div style="display: flex; gap: 10px;">
                <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1;">
                <button id="send-chat-btn">Send</button>
            </div>
        </div>

        <!-- File Transfer Section -->
        <div id="file-section" class="section hidden">
            <h2>üìÅ File Transfer</h2>
            
            <div class="file-transfer">
                <input type="file" id="file-input">
                <button id="send-file-btn" class="btn-success">Send File</button>
            </div>

            <div id="send-progress" class="progress-section hidden">
                <strong>Sending:</strong> <span id="send-filename"></span>
                <progress id="send-progress-bar" value="0" max="100"></progress>
                <div id="send-status">Preparing...</div>
            </div>

            <div id="receive-progress" class="progress-section hidden">
                <strong>Receiving:</strong> <span id="receive-filename"></span>
                <progress id="receive-progress-bar" value="0" max="100"></progress>
                <div id="receive-status">Receiving...</div>
            </div>

            <div id="download-area"></div>
        </div>
    </div>

    <script>
        let peerConnection = null;
        let dataChannel = null;
        let isInitiator = false;

        // File transfer state
        let receivedFileData = [];
        let receivedFileInfo = null;
        let receivedBytes = 0;

        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun.services.mozilla.com:3478' }
            ]
        };

        // UI Elements
        const elements = {
            status: document.getElementById('status'),
            offerOutput: document.getElementById('offer-output'),
            offerInput: document.getElementById('offer-input'),
            answerOutput: document.getElementById('answer-output'),
            answerInput: document.getElementById('answer-input'),
            iceOutput: document.getElementById('ice-output'),
            iceInput: document.getElementById('ice-input'),
            chatSection: document.getElementById('chat-section'),
            fileSection: document.getElementById('file-section'),
            chatLog: document.getElementById('chat-log'),
            chatInput: document.getElementById('chat-input'),
            fileInput: document.getElementById('file-input'),
            sendProgress: document.getElementById('send-progress'),
            receiveProgress: document.getElementById('receive-progress'),
            downloadArea: document.getElementById('download-area'),
            localIpDisplay: document.getElementById('local-ip-display'),
            targetIpInput: document.getElementById('target-ip-input'),
            targetPortInput: document.getElementById('target-port-input'),
            listenBtn: document.getElementById('listen-btn'),
            stopListenBtn: document.getElementById('stop-listen-btn'),
            connectIpBtn: document.getElementById('connect-ip-btn')
        };

        // Local IP detection
        async function detectLocalIP() {
            try {
                // Create a temporary RTCPeerConnection to get local IP
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // Create a data channel to trigger ICE candidate generation
                pc.createDataChannel('');
                
                // Create offer to start the process
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                return new Promise((resolve) => {
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            const candidate = event.candidate.candidate;
                            const ipMatch = candidate.match(/(\d{1,3}\.){3}\d{1,3}/);
                            if (ipMatch && !ipMatch[0].startsWith('127.') && !ipMatch[0].startsWith('0.')) {
                                pc.close();
                                resolve(ipMatch[0]);
                            }
                        }
                    };
                    
                    // Fallback timeout
                    setTimeout(() => {
                        pc.close();
                        resolve('Unable to detect');
                    }, 3000);
                });
            } catch (error) {
                console.error('Error detecting local IP:', error);
                return 'Unable to detect';
            }
        }

        async function updateLocalIP() {
            elements.localIpDisplay.textContent = 'Detecting...';
            const localIP = await detectLocalIP();
            elements.localIpDisplay.textContent = localIP;
            
            // Auto-fill a common IP range suggestion if detection fails
            if (localIP === 'Unable to detect') {
                elements.targetIpInput.placeholder = 'Enter target device IP (e.g., 192.168.1.100, 192.168.0.100, 10.0.0.100)';
            } else {
                // Suggest IP in same subnet
                const ipParts = localIP.split('.');
                ipParts[3] = 'XXX';
                elements.targetIpInput.placeholder = `Enter target device IP (e.g., ${ipParts.join('.')})`;
            }
        }

        function updateStatus(message, type = 'disconnected') {
            elements.status.textContent = message;
            elements.status.className = `status status-${type}`;
        }

        function logMessage(sender, message, type = 'peer') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message chat-${type}`;
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            elements.chatLog.appendChild(messageDiv);
            elements.chatLog.scrollTop = elements.chatLog.scrollHeight;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function initializePeerConnection() {
            if (peerConnection) {
                peerConnection.close();
            }

            peerConnection = new RTCPeerConnection(configuration);
            elements.iceOutput.value = '';

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    elements.iceOutput.value += JSON.stringify(event.candidate) + '\n';
                    console.log('ICE candidate generated');
                    
                    // Auto-send ICE candidates if we have active signaling connections
                    if (listeningPeer && listeningPeer.readyState === WebSocket.OPEN) {
                        listeningPeer.send(JSON.stringify({
                            type: 'webrtc_ice',
                            candidate: event.candidate,
                            to: 'connector', // Will be updated by listener
                            from: 'listener'
                        }));
                    } else if (connectingPeer && connectingPeer.readyState === WebSocket.OPEN) {
                        connectingPeer.send(JSON.stringify({
                            type: 'webrtc_ice',
                            candidate: event.candidate,
                            to: 'listener', // Will be updated by connector
                            from: 'connector'
                        }));
                    }
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                console.log('ICE connection state:', state);
                
                if (state === 'connected' || state === 'completed') {
                    updateStatus('Connected!', 'connected');
                } else if (state === 'disconnected' || state === 'failed') {
                    updateStatus('Disconnected', 'disconnected');
                    elements.chatSection.classList.add('hidden');
                    elements.fileSection.classList.add('hidden');
                } else {
                    updateStatus('Connecting...', 'connecting');
                }
            };

            peerConnection.ondatachannel = (event) => {
                console.log('Data channel received');
                dataChannel = event.channel;
                setupDataChannel();
            };

            // Reset file transfer state
            receivedFileData = [];
            receivedFileInfo = null;
            receivedBytes = 0;
        }

        function setupDataChannel() {
            if (!dataChannel) return;

            dataChannel.binaryType = 'arraybuffer';

            dataChannel.onopen = () => {
                console.log('Data channel opened');
                updateStatus('Ready for chat and file transfer!', 'connected');
                elements.chatSection.classList.remove('hidden');
                elements.fileSection.classList.remove('hidden');
                elements.chatInput.focus();
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                updateStatus('Data channel closed', 'disconnected');
                elements.chatSection.classList.add('hidden');
                elements.fileSection.classList.add('hidden');
            };

            dataChannel.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage(data);
                    } catch (e) {
                        logMessage('Peer', event.data);
                    }
                } else if (event.data instanceof ArrayBuffer) {
                    handleFileChunk(event.data);
                }
            };
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'chat':
                    logMessage('Peer', data.message);
                    break;
                case 'file-start':
                    startReceivingFile(data);
                    break;
                case 'file-end':
                    finishReceivingFile();
                    break;
            }
        }

        function startReceivingFile(fileInfo) {
            receivedFileInfo = fileInfo;
            receivedFileData = [];
            receivedBytes = 0;

            document.getElementById('receive-filename').textContent = fileInfo.name;
            document.getElementById('receive-progress-bar').max = fileInfo.size;
            document.getElementById('receive-progress-bar').value = 0;
            document.getElementById('receive-status').textContent = 'Starting...';
            elements.receiveProgress.classList.remove('hidden');

            logMessage('System', `Receiving: ${fileInfo.name} (${formatBytes(fileInfo.size)})`, 'system');
        }

        function handleFileChunk(chunk) {
            if (!receivedFileInfo) return;

            receivedFileData.push(chunk);
            receivedBytes += chunk.byteLength;

            const progress = (receivedBytes / receivedFileInfo.size) * 100;
            document.getElementById('receive-progress-bar').value = receivedBytes;
            document.getElementById('receive-status').textContent = 
                `${formatBytes(receivedBytes)} / ${formatBytes(receivedFileInfo.size)} (${progress.toFixed(1)}%)`;

            if (receivedBytes >= receivedFileInfo.size) {
                finishReceivingFile();
            }
        }

        function finishReceivingFile() {
            if (!receivedFileInfo || receivedFileData.length === 0) return;

            const blob = new Blob(receivedFileData, { type: receivedFileInfo.type });
            const url = URL.createObjectURL(blob);

            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = receivedFileInfo.name;
            downloadLink.className = 'download-link';
            downloadLink.textContent = `üì• Download ${receivedFileInfo.name} (${formatBytes(receivedFileInfo.size)})`;

            elements.downloadArea.appendChild(downloadLink);
            elements.receiveProgress.classList.add('hidden');

            logMessage('System', `File received: ${receivedFileInfo.name}`, 'system');

            // Reset state
            receivedFileInfo = null;
            receivedFileData = [];
            receivedBytes = 0;
        }

        async function sendFile(file) {
            if (!dataChannel || dataChannel.readyState !== 'open') {
                alert('Data channel not ready');
                return;
            }

            // Send file metadata
            const fileInfo = {
                type: 'file-start',
                name: file.name,
                size: file.size,
                fileType: file.type
            };

            dataChannel.send(JSON.stringify(fileInfo));

            // Setup progress tracking
            document.getElementById('send-filename').textContent = file.name;
            document.getElementById('send-progress-bar').max = file.size;
            document.getElementById('send-progress-bar').value = 0;
            elements.sendProgress.classList.remove('hidden');

            logMessage('System', `Sending: ${file.name} (${formatBytes(file.size)})`, 'system');

            // Send file in chunks
            const chunkSize = 16 * 1024; // 16KB chunks
            let offset = 0;

            const sendChunk = () => {
                if (offset >= file.size) {
                    // File complete
                    dataChannel.send(JSON.stringify({ type: 'file-end' }));
                    elements.sendProgress.classList.add('hidden');
                    logMessage('System', `File sent: ${file.name}`, 'system');
                    return;
                }

                const chunk = file.slice(offset, offset + chunkSize);
                const reader = new FileReader();

                reader.onload = (e) => {
                    if (dataChannel.readyState === 'open') {
                        dataChannel.send(e.target.result);
                        offset += e.target.result.byteLength;

                        const progress = (offset / file.size) * 100;
                        document.getElementById('send-progress-bar').value = offset;
                        document.getElementById('send-status').textContent = 
                            `${formatBytes(offset)} / ${formatBytes(file.size)} (${progress.toFixed(1)}%)`;

                        // Send next chunk with small delay to prevent overwhelming
                        setTimeout(sendChunk, 10);
                    }
                };

                reader.readAsArrayBuffer(chunk);
            };

            sendChunk();
        }

        // Listen/Connect system
        let isListening = false;
        let listeningPeer = null;
        let connectingPeer = null;

        function updateListenStatus(message, show = true) {
            const statusDiv = document.getElementById('listen-status');
            const statusText = document.getElementById('listen-status-text');
            
            if (statusDiv && statusText) {
                statusText.textContent = message;
                statusDiv.style.display = show ? 'block' : 'none';
            }
        }

        async function startListening() {
            if (isListening) return;
            
            isListening = true;
            
            // Show UI changes
            document.getElementById('listen-btn').style.display = 'none';
            document.getElementById('stop-listen-btn').style.display = 'flex';
            updateListenStatus('Connecting to signaling server...');
            updateStatus('Starting listener...', 'connecting');
            logMessage('System', 'Starting listening mode', 'system');
            
            try {
                // Connect to signaling server
                const ws = new WebSocket('wss://ws.postman-echo.com/raw');
                listeningPeer = ws;
                
                const localIP = elements.localIpDisplay.textContent;
                const listenerId = `listener_${localIP}_${Date.now()}`;
                
                ws.onopen = () => {
                    updateListenStatus(`Listening on ${localIP} - Ready for connections!`);
                    updateStatus('Listening for connections...', 'connecting');
                    logMessage('System', `Listening on IP: ${localIP}`, 'system');
                    
                    // Announce as listener
                    ws.send(JSON.stringify({
                        type: 'announce_listener',
                        id: listenerId,
                        ip: localIP
                    }));
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        await handleListenerMessage(data, ws, listenerId);
                    } catch (e) {
                        console.log('Non-JSON message received');
                    }
                };
                
                ws.onclose = () => {
                    logMessage('System', 'Signaling connection closed', 'system');
                    stopListening();
                };
                
                ws.onerror = () => {
                    updateStatus('Failed to start listening', 'disconnected');
                    updateListenStatus('Failed to connect to signaling server');
                    stopListening();
                };
                
            } catch (error) {
                console.error('Error starting listener:', error);
                updateStatus('Failed to start listening', 'disconnected');
                updateListenStatus('Failed to start listening');
                stopListening();
            }
        }

        function stopListening() {
            isListening = false;
            
            // Show UI changes
            document.getElementById('listen-btn').style.display = 'flex';
            document.getElementById('stop-listen-btn').style.display = 'none';
            updateListenStatus('Not listening', false);
            updateStatus('Stopped listening', 'disconnected');
            logMessage('System', 'Stopped listening', 'system');
            
            if (listeningPeer) {
                listeningPeer.close();
                listeningPeer = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
        }

        async function handleListenerMessage(data, ws, listenerId) {
            if (data.type === 'connect_request' && data.targetIP === elements.localIpDisplay.textContent) {
                logMessage('System', `Connection request from ${data.fromIP}`, 'system');
                updateStatus('Incoming connection...', 'connecting');
                
                // Initialize peer connection as listener (receiver)
                initializePeerConnection();
                isInitiator = false;
                
                // Wait for offer from connector
            } else if (data.type === 'webrtc_offer' && data.to === listenerId) {
                logMessage('System', 'Received connection offer', 'system');
                
                try {
                    // Set remote description (offer)
                    await peerConnection.setRemoteDescription(data.offer);
                    
                    // Create and send answer
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    
                    ws.send(JSON.stringify({
                        type: 'webrtc_answer',
                        answer: answer,
                        to: data.from,
                        from: listenerId
                    }));
                    
                    logMessage('System', 'Sent connection answer', 'system');
                } catch (e) {
                    console.error('Error handling offer:', e);
                    updateStatus('Connection failed', 'disconnected');
                }
            } else if (data.type === 'webrtc_ice' && data.to === listenerId) {
                try {
                    await peerConnection.addIceCandidate(data.candidate);
                } catch (e) {
                    console.error('Error adding ICE candidate:', e);
                }
            }
        }

        function broadcastPresence() {
            if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'presence',
                    id: localId,
                    timestamp: Date.now()
                };
                signalingSocket.send(JSON.stringify(message));
            }
        }

        function startPeerDiscovery() {
            // Broadcast presence every 5 seconds
            setInterval(() => {
                if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                    broadcastPresence();
                }
            }, 5000);
        }

        function handleSignalingMessage(data) {
            if (data.type === 'presence' && data.id !== localId) {
                logMessage('System', `Found peer: ${data.id}`, 'system');
                updateDiscoveryStatus(`Found device ${data.id.substr(0, 4)}... - connecting!`);
                // Auto-initiate connection if we have a smaller ID (to avoid duplicate connections)
                if (localId < data.id && !peerConnection) {
                    setTimeout(() => createAutoOffer(data.id), 1000);
                }
            }
        }

        async function createAutoOffer(peerId) {
            logMessage('System', `Auto-connecting to peer: ${peerId}`, 'system');
            updateStatus('Auto-connecting to peer...', 'connecting');
            
            initializePeerConnection();
            isInitiator = true;

            // Create data channel
            dataChannel = peerConnection.createDataChannel('fileTransfer', {
                ordered: true
            });
            setupDataChannel();

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                // Send offer through signaling server
                if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                    const message = {
                        type: 'offer',
                        offer: offer,
                        from: localId,
                        to: peerId
                    };
                    signalingSocket.send(JSON.stringify(message));
                }
            } catch (e) {
                console.error('Error creating auto offer:', e);
                updateStatus('Auto-connection failed', 'disconnected');
            }
        }

        // Connect to IP function
        async function connectToIP() {
            const targetIP = elements.targetIpInput.value.trim();
            const targetPort = elements.targetPortInput.value || '3000';
            
            if (!targetIP) {
                alert('Please enter the IP address of the listening device');
                return;
            }
            
            // Validate IP format
            const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
            if (!ipRegex.test(targetIP)) {
                alert('Please enter a valid IP address (e.g., 192.168.1.100)');
                return;
            }
            
            updateStatus(`Connecting to ${targetIP}...`, 'connecting');
            logMessage('System', `Looking for listener on ${targetIP}`, 'system');
            
            try {
                // Connect to signaling server
                const ws = new WebSocket('wss://ws.postman-echo.com/raw');
                connectingPeer = ws;
                
                const localIP = elements.localIpDisplay.textContent;
                const connectorId = `connector_${localIP}_${Date.now()}`;
                
                ws.onopen = () => {
                    logMessage('System', 'Connected to signaling server', 'system');
                    
                    // Send connection request
                    ws.send(JSON.stringify({
                        type: 'connect_request',
                        targetIP: targetIP,
                        fromIP: localIP,
                        from: connectorId
                    }));
                    
                    // Initialize peer connection as connector (initiator)
                    initializePeerConnection();
                    isInitiator = true;

                    // Create data channel
                    dataChannel = peerConnection.createDataChannel('fileTransfer', {
                        ordered: true
                    });
                    setupDataChannel();
                    
                    // Create and send offer
                    setTimeout(async () => {
                        try {
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);
                            
                            ws.send(JSON.stringify({
                                type: 'webrtc_offer',
                                offer: offer,
                                to: `listener_${targetIP}`,
                                from: connectorId
                            }));
                            
                            logMessage('System', 'Sent connection offer', 'system');
                        } catch (e) {
                            console.error('Error creating offer:', e);
                            updateStatus('Failed to create offer', 'disconnected');
                        }
                    }, 1000);
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        await handleConnectorMessage(data, ws, connectorId);
                    } catch (e) {
                        console.log('Non-JSON message received');
                    }
                };
                
                ws.onclose = () => {
                    logMessage('System', 'Signaling connection closed', 'system');
                    if (connectingPeer) {
                        connectingPeer = null;
                        updateStatus('Connection failed', 'disconnected');
                    }
                };
                
                ws.onerror = () => {
                    updateStatus('Failed to connect to signaling server', 'disconnected');
                    logMessage('System', 'Could not reach signaling server', 'system');
                };
                
            } catch (error) {
                console.error('Connection error:', error);
                updateStatus(`Failed to connect to ${targetIP}`, 'disconnected');
                logMessage('System', `Connection failed: ${error.message}`, 'system');
            }
        }

        async function handleConnectorMessage(data, ws, connectorId) {
            if (data.type === 'webrtc_answer' && data.to === connectorId) {
                logMessage('System', 'Received connection answer', 'system');
                
                try {
                    await peerConnection.setRemoteDescription(data.answer);
                    logMessage('System', 'Connection established!', 'system');
                } catch (e) {
                    console.error('Error handling answer:', e);
                    updateStatus('Connection failed', 'disconnected');
                }
            } else if (data.type === 'webrtc_ice' && data.to === connectorId) {
                try {
                    await peerConnection.addIceCandidate(data.candidate);
                } catch (e) {
                    console.error('Error adding ICE candidate:', e);
                }
            }
        }

        // Local storage functions for IP persistence
        function saveTargetIP() {
            const targetIP = elements.targetIpInput.value.trim();
            if (targetIP) {
                localStorage.setItem('fileTransfer_targetIP', targetIP);
            }
        }

        function loadTargetIP() {
            const savedIP = localStorage.getItem('fileTransfer_targetIP');
            if (savedIP) {
                elements.targetIpInput.value = savedIP;
            }
        }

        function hideQRCode() {
            document.getElementById('qr-container').classList.add('hidden');
        }

        // Event Listeners
        document.getElementById('refresh-ip-btn').onclick = updateLocalIP;
        document.getElementById('listen-btn').onclick = startListening;
        document.getElementById('stop-listen-btn').onclick = stopListening;
        
        document.getElementById('connect-ip-btn').onclick = () => {
            saveTargetIP();
            connectToIP();
        };

        document.getElementById('qr-close-btn').onclick = hideQRCode;
        
        // Save IP when user types
        elements.targetIpInput.addEventListener('input', saveTargetIP);

        document.getElementById('create-offer-btn').onclick = async () => {
            initializePeerConnection();
            isInitiator = true;

            // Create data channel
            dataChannel = peerConnection.createDataChannel('fileTransfer', {
                ordered: true
            });
            setupDataChannel();

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                elements.offerOutput.value = JSON.stringify(offer);
                updateStatus('Offer created - copy to other device', 'connecting');
            } catch (e) {
                console.error('Error creating offer:', e);
                updateStatus('Error creating offer', 'disconnected');
            }
        };

        document.getElementById('create-answer-btn').onclick = async () => {
            const offerJson = elements.offerInput.value.trim();
            if (!offerJson) {
                alert('Please paste the offer first');
                return;
            }

            initializePeerConnection();
            isInitiator = false;

            try {
                const offer = JSON.parse(offerJson);
                await peerConnection.setRemoteDescription(offer);
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                elements.answerOutput.value = JSON.stringify(answer);
                updateStatus('Answer created - copy to other device', 'connecting');
            } catch (e) {
                console.error('Error creating answer:', e);
                updateStatus('Error creating answer', 'disconnected');
            }
        };

        document.getElementById('set-answer-btn').onclick = async () => {
            const answerJson = elements.answerInput.value.trim();
            if (!answerJson) {
                alert('Please paste the answer first');
                return;
            }

            try {
                const answer = JSON.parse(answerJson);
                await peerConnection.setRemoteDescription(answer);
                updateStatus('Answer set - exchange ICE candidates', 'connecting');
            } catch (e) {
                console.error('Error setting answer:', e);
                updateStatus('Error setting answer', 'disconnected');
            }
        };

        document.getElementById('add-ice-btn').onclick = async () => {
            const candidatesText = elements.iceInput.value.trim();
            if (!candidatesText) {
                alert('Please paste ICE candidates first');
                return;
            }

            const lines = candidatesText.split('\n').filter(line => line.trim());
            let added = 0;

            for (const line of lines) {
                try {
                    const candidate = JSON.parse(line.trim());
                    await peerConnection.addIceCandidate(candidate);
                    added++;
                } catch (e) {
                    console.error('Error adding ICE candidate:', e);
                }
            }

            console.log(`Added ${added} ICE candidates`);
            elements.iceInput.value = '';
            updateStatus(`Added ${added} ICE candidates`, 'connecting');
        };

        document.getElementById('send-chat-btn').onclick = () => {
            const message = elements.chatInput.value.trim();
            if (!message || !dataChannel || dataChannel.readyState !== 'open') return;

            const data = {
                type: 'chat',
                message: message
            };

            dataChannel.send(JSON.stringify(data));
            logMessage('Me', message, 'me');
            elements.chatInput.value = '';
        };

        elements.chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('send-chat-btn').click();
            }
        });

        document.getElementById('send-file-btn').onclick = () => {
            const file = elements.fileInput.files[0];
            if (!file) {
                alert('Please select a file first');
                return;
            }

            sendFile(file);
            elements.fileInput.value = '';
        };

        // Generate QR code for current page URL
        function generateQRCode() {
            const qrContainer = document.getElementById('qr-code');
            const urlText = document.getElementById('qr-url-text');
            const currentURL = window.location.href;
            
            // Display the URL
            urlText.textContent = currentURL;
            
            try {
                // Clear any existing QR code
                qrContainer.innerHTML = '';
                
                // Generate QR code using QRCode.js
                const qrcode = new QRCode(qrContainer, {
                    text: currentURL,
                    width: 200,
                    height: 200,
                    colorDark: '#000000',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.M
                });
                
                console.log('QR Code generated successfully');
            } catch (error) {
                console.error('QR Code generation error:', error);
                qrContainer.innerHTML = '<div style="width:200px; height:200px; background:#f0f0f0; display:flex; align-items:center; justify-content:center; border:1px solid #ddd;">QR Code Failed</div>';
                urlText.textContent = 'QR code generation failed: ' + error.message;
            }
        }

        // Initialize
        updateStatus('Ready to connect', 'disconnected');
        
        // Auto-detect local IP on page load
        updateLocalIP();
        
        // Load saved target IP
        loadTargetIP();
        
        // Generate QR code on page load with delay to ensure DOM is ready
        setTimeout(() => {
            generateQRCode();
        }, 1000);
    </script>
</body>
</html>